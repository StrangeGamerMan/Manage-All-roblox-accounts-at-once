// Node backend (run on your machine or any Node host)
// Change port: set PORT env var or edit the default below.

const express = require('express');
const path = require('path');
const fetch = require('node-fetch'); // v2

const app = express();

// Change port here or via environment variable
const PORT = Number(process.env.PORT || 3000);

// Allow only your GitHub Pages origin in CORS for safety
const ALLOW_ORIGIN = process.env.ALLOW_ORIGIN || '*'; // e.g., 'https://yourname.github.io'

app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', ALLOW_ORIGIN);
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

app.use(express.json({ limit: '1mb' }));
app.use(express.static(path.join(__dirname))); // optional: serves index.html if you visit backend directly

app.get('/api/health', (req, res) => res.json({ ok: true }));

app.post('/api/run', async (req, res) => {
  try {
    const { accounts, command } = req.body || {};
    if (!Array.isArray(accounts) || !accounts.length || typeof command !== 'string') {
      return res.status(400).json({ error: 'Invalid payload.' });
    }

    const results = [];
    for (const acct of accounts) {
      const label = acct.label || 'Account';
      const cookie = (acct.cookie || '').trim();
      if (!cookie) { results.push({ label, ok: false, message: 'Missing cookie.' }); continue; }

      try {
        const result = await handleCommand(label, cookie, command);
        results.push({ label, ok: true, ...result });
      } catch (err) {
        results.push({ label, ok: false, message: err?.message || String(err) });
      }

      await delay(400);
    }

    res.json({ results });
  } catch (e) {
    res.status(500).send(e?.message || 'Server error');
  }
});

app.listen(PORT, () => {
  console.log(`Server running at http://127.0.0.1:${PORT}`);
});

// ---- Roblox helpers ----
async function handleCommand(label, cookie, commandRaw) {
  const command = commandRaw.trim();
  const lower = command.toLowerCase();

  const me = await getAuthenticatedUser(cookie);
  if (!me?.id) throw new Error('Authentication failed. Cookie may be invalid.');

  if (lower.startsWith('follow ')) {
    const targetName = command.split(' ').slice(1).join(' ').trim();
    if (!targetName) throw new Error('Missing username to follow.');
    const xcsrf = await getXcsrf(cookie);
    const targetId = await getUserIdByUsername(targetName, cookie, xcsrf);
    await followUser(cookie, xcsrf, targetId);
    return { action: 'follow', message: `${me.name} (${me.id}) now follows ${targetName} (${targetId})` };
  }

  if (lower === 'acceptfriends' || lower === 'acceptfriend' || lower === 'acceptfriends()') {
    const xcsrf = await getXcsrf(cookie);
    const count = await acceptAllFriendRequests(cookie, xcsrf);
    return { action: 'acceptfriends', message: `${me.name} (${me.id}) accepted ${count} friend request(s)` };
  }

  if (lower.startsWith('join ')) throw new Error('Join is not supported via web APIs.');

  throw new Error(`Command "${command}" not recognized or not supported.`);
}

async function getAuthenticatedUser(cookie) {
  const res = await fetch('https://users.roblox.com/v1/users/authenticated', {
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  if (!res.ok) throw new Error(`Auth check failed (${res.status}).`);
  return res.json();
}

async function getXcsrf(cookie) {
  const res = await fetch('https://auth.roblox.com/v2/login', {
    method: 'POST',
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  const token = res.headers.get('x-csrf-token');
  if (!token) throw new Error('Failed to obtain X-CSRF token.');
  return token;
}

async function getUserIdByUsername(username, cookie, xcsrf) {
  const res = await fetch('https://users.roblox.com/v1/usernames/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Cookie': `.ROBLOSECURITY=${cookie}`,
      'x-csrf-token': xcsrf
    },
    body: JSON.stringify({ usernames: [username], excludeBannedUsers: false })
  });
  if (!res.ok) throw new Error(`Username lookup failed (${res.status}): ${await safeText(res)}`);
  const data = await res.json();
  const match = data?.data?.[0];
  if (!match?.id) throw new Error(`User "${username}" not found.`);
  return match.id;
}

async function followUser(cookie, xcsrf, targetUserId) {
  const res = await fetch(`https://friends.roblox.com/v1/users/${targetUserId}/follow`, {
    method: 'POST',
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}`, 'x-csrf-token': xcsrf }
  });
  if (!res.ok) throw new Error(`Follow failed (${res.status}): ${await safeText(res)}`);
}

async function listFriendRequests(cookie) {
  const res = await fetch('https://friends.roblox.com/v1/my/friends/requests?limit=100&sortOrder=Asc', {
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  if (!res.ok) throw new Error(`Could not fetch friend requests (${res.status}).`);
  const data = await res.json();
  return Array.isArray(data?.data) ? data.data : [];
}

async function acceptAllFriendRequests(cookie, xcsrf) {
  const requests = await listFriendRequests(cookie);
  let count = 0;
  for (const r of requests) {
    const requesterId = r.requesterUserId ?? r.requesterId ?? r.id ?? r.userId;
    if (!requesterId) continue;
    const res = await fetch(`https://friends.roblox.com/v1/users/${requesterId}/accept-friend-request`, {
      method: 'POST',
      headers: { 'Cookie': `.ROBLOSECURITY=${cookie}`, 'x-csrf-token': xcsrf }
    });
    if (res.ok) count++;
    await delay(250);
  }
  return count;
}

function delay(ms){ return new Promise(r => setTimeout(r, ms)); }
async function safeText(res){ try{ return await res.text(); } catch{ return ''; } }
