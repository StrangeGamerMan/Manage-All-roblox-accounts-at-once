// Node backend (Render Web Service). Redacts secrets; supports CORS via ALLOW_ORIGIN.
// Start command: node server.js
// Env vars:
//   ALLOW_ORIGIN = https://yourname.github.io   (your GitHub Pages URL)  or "*" while testing

const express = require('express');
const fetch = require('node-fetch'); // v2

const app = express();
const PORT = Number(process.env.PORT || 3000);
const ALLOW_ORIGIN = process.env.ALLOW_ORIGIN || '*';

function redactSecrets(str = '') {
  if (typeof str !== 'string') str = String(str || '');
  str = str.replace(/(_\|WARNING:-DO-NOT-SHARE-THIS[^"\s]+)/gi, '[REDACTED_COOKIE]');
  str = str.replace(/\.ROBLOSECURITY=[^;]+/gi, '.ROBLOSECURITY=[REDACTED]');
  return str;
}
function safeMessage(err) {
  try { return redactSecrets(err?.message || String(err || 'Error')); }
  catch { return 'Error'; }
}

app.set('trust proxy', true);

// CORS
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', ALLOW_ORIGIN);
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

app.use(express.json({ limit: '200kb' }));

app.get('/api/health', (req, res) => res.json({ ok: true }));

app.post('/api/run', async (req, res) => {
  try {
    const { accounts, command } = req.body || {};
    if (!Array.isArray(accounts) || !accounts.length || typeof command !== 'string') {
      return res.status(400).json({ error: 'Invalid payload.' });
    }

    const results = [];
    for (const acct of accounts) {
      const label = (acct?.label || 'Account').slice(0, 64);
      const cookie = (acct?.cookie || '').trim();
      if (!cookie) { results.push({ label, ok: false, message: 'Missing cookie.' }); continue; }

      try {
        const result = await handleCommand(label, cookie, command);
        results.push({ label, ok: true, ...result });
      } catch (err) {
        results.push({ label, ok: false, message: safeMessage(err) });
      }

      await delay(350);
    }
    res.json({ results });
  } catch {
    res.status(500).json({ error: 'Server error' });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// -------- Roblox helpers --------
async function handleCommand(label, cookie, commandRaw) {
  const command = commandRaw.trim();
  const lower = command.toLowerCase();

  const me = await getAuthenticatedUser(cookie);
  if (!me?.id) throw new Error('Authentication failed. Cookie may be invalid.');

  if (lower.startsWith('follow ')) {
    const targetName = command.split(' ').slice(1).join(' ').trim();
    if (!targetName) throw new Error('Missing username to follow.');
    const xcsrf = await getXcsrf(cookie);
    const targetId = await getUserIdByUsername(targetName, cookie, xcsrf);
    await followUser(cookie, xcsrf, targetId);
    return { action: 'follow', message: `${me.name} (${me.id}) now follows ${targetName} (${targetId})` };
  }

  if (lower === 'acceptfriends' || lower === 'acceptfriend' || lower === 'acceptfriends()') {
    const xcsrf = await getXcsrf(cookie);
    const count = await acceptAllFriendRequests(cookie, xcsrf);
    return { action: 'acceptfriends', message: `${me.name} (${me.id}) accepted ${count} friend request(s)` };
  }

  if (lower.startsWith('join ')) throw new Error('Join is not supported via web APIs.');

  throw new Error(`Command "${command}" not recognized or not supported.`);
}

async function getAuthenticatedUser(cookie) {
  const res = await fetch('https://users.roblox.com/v1/users/authenticated', {
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  if (!res.ok) throw new Error(`Auth check failed (${res.status}).`);
  return res.json();
}

async function getXcsrf(cookie) {
  const res = await fetch('https://auth.roblox.com/v2/login', {
    method: 'POST',
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  const token = res.headers.get('x-csrf-token');
  if (!token) throw new Error('Failed to obtain X-CSRF token.');
  return token;
}

async function getUserIdByUsername(username, cookie, xcsrf) {
  const res = await fetch('https://users.roblox.com/v1/usernames/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Cookie': `.ROBLOSECURITY=${cookie}`,
      'x-csrf-token': xcsrf
    },
    body: JSON.stringify({ usernames: [username], excludeBannedUsers: false })
  });
  if (!res.ok) throw new Error(`Username lookup failed (${res.status}).`);
  const data = await res.json();
  const match = data?.data?.[0];
  if (!match?.id) throw new Error(`User "${username}" not found.`);
  return match.id;
}

async function followUser(cookie, xcsrf, targetUserId) {
  const res = await fetch(`https://friends.roblox.com/v1/users/${targetUserId}/follow`, {
    method: 'POST',
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}`, 'x-csrf-token': xcsrf }
  });
  if (!res.ok) throw new Error(`Follow failed (${res.status}).`);
}

async function listFriendRequests(cookie) {
  const res = await fetch('https://friends.roblox.com/v1/my/friends/requests?limit=100&sortOrder=Asc', {
    headers: { 'Cookie': `.ROBLOSECURITY=${cookie}` }
  });
  if (!res.ok) throw new Error(`Could not fetch friend requests (${res.status}).`);
  const data = await res.json();
  return Array.isArray(data?.data) ? data.data : [];
}

async function acceptAllFriendRequests(cookie, xcsrf) {
  const requests = await listFriendRequests(cookie);
  let count = 0;
  for (const r of requests) {
    const requesterId = r.requesterUserId ?? r.requesterId ?? r.id ?? r.userId;
    if (!requesterId) continue;
    const res = await fetch(`https://friends.roblox.com/v1/users/${requesterId}/accept-friend-request`, {
      method: 'POST',
      headers: { 'Cookie': `.ROBLOSECURITY=${cookie}`, 'x-csrf-token': xcsrf }
    });
    if (res.ok) count++;
    await delay(250);
  }
  return count;
}

function delay(ms){ return new Promise(r => setTimeout(r, ms)); }
